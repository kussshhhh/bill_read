// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addReceiptItem = `-- name: AddReceiptItem :exec
INSERT INTO receipt_items (
    receipt_id, name, quantity, 
    price_per_item, total_price
) VALUES (
    $1, $2, $3, $4, $5
)
`

type AddReceiptItemParams struct {
	ReceiptID    pgtype.UUID
	Name         string
	Quantity     int32
	PricePerItem pgtype.Numeric
	TotalPrice   pgtype.Numeric
}

func (q *Queries) AddReceiptItem(ctx context.Context, arg AddReceiptItemParams) error {
	_, err := q.db.Exec(ctx, addReceiptItem,
		arg.ReceiptID,
		arg.Name,
		arg.Quantity,
		arg.PricePerItem,
		arg.TotalPrice,
	)
	return err
}

const createReceipt = `-- name: CreateReceipt :one

INSERT INTO receipts (
    user_id, name_of_establishment, currency, 
    number_of_items, subtotal, tax_value, tax_na,
    tip_value, tip_na, additional_charges_value,
    additional_charges_na, total, image_data,
    image_content_type, status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, 
    $10, $11, $12, $13, $14, $15
) 
RETURNING receipt_id
`

type CreateReceiptParams struct {
	UserID                 pgtype.UUID
	NameOfEstablishment    pgtype.Text
	Currency               pgtype.Text
	NumberOfItems          int32
	Subtotal               pgtype.Numeric
	TaxValue               pgtype.Numeric
	TaxNa                  pgtype.Bool
	TipValue               pgtype.Numeric
	TipNa                  pgtype.Bool
	AdditionalChargesValue pgtype.Numeric
	AdditionalChargesNa    pgtype.Bool
	Total                  pgtype.Numeric
	ImageData              []byte
	ImageContentType       pgtype.Text
	Status                 bool
}

// Receipt Management Queries
func (q *Queries) CreateReceipt(ctx context.Context, arg CreateReceiptParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createReceipt,
		arg.UserID,
		arg.NameOfEstablishment,
		arg.Currency,
		arg.NumberOfItems,
		arg.Subtotal,
		arg.TaxValue,
		arg.TaxNa,
		arg.TipValue,
		arg.TipNa,
		arg.AdditionalChargesValue,
		arg.AdditionalChargesNa,
		arg.Total,
		arg.ImageData,
		arg.ImageContentType,
		arg.Status,
	)
	var receipt_id pgtype.UUID
	err := row.Scan(&receipt_id)
	return receipt_id, err
}

const createUser = `-- name: CreateUser :one

INSERT INTO users (email, password_hash) 
VALUES ($1, $2) 
RETURNING user_id
`

type CreateUserParams struct {
	Email        string
	PasswordHash string
}

// User Management Queries
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Email, arg.PasswordHash)
	var user_id pgtype.UUID
	err := row.Scan(&user_id)
	return user_id, err
}

const deleteReceipt = `-- name: DeleteReceipt :exec
DELETE FROM receipts 
WHERE receipt_id = $1 AND user_id = $2
`

type DeleteReceiptParams struct {
	ReceiptID pgtype.UUID
	UserID    pgtype.UUID
}

func (q *Queries) DeleteReceipt(ctx context.Context, arg DeleteReceiptParams) error {
	_, err := q.db.Exec(ctx, deleteReceipt, arg.ReceiptID, arg.UserID)
	return err
}

const getReceiptImage = `-- name: GetReceiptImage :one
SELECT image_data, image_content_type 
FROM receipts 
WHERE receipt_id = $1
`

type GetReceiptImageRow struct {
	ImageData        []byte
	ImageContentType pgtype.Text
}

func (q *Queries) GetReceiptImage(ctx context.Context, receiptID pgtype.UUID) (GetReceiptImageRow, error) {
	row := q.db.QueryRow(ctx, getReceiptImage, receiptID)
	var i GetReceiptImageRow
	err := row.Scan(&i.ImageData, &i.ImageContentType)
	return i, err
}

const getReceiptStatistics = `-- name: GetReceiptStatistics :one
SELECT 
    COUNT(*) as total_receipts,
    SUM(total) as total_spent,
    AVG(total) as average_receipt_amount,
    MIN(total) as min_receipt_amount,
    MAX(total) as max_receipt_amount
FROM receipts 
WHERE user_id = $1
`

type GetReceiptStatisticsRow struct {
	TotalReceipts        int64
	TotalSpent           int64
	AverageReceiptAmount float64
	MinReceiptAmount     interface{}
	MaxReceiptAmount     interface{}
}

func (q *Queries) GetReceiptStatistics(ctx context.Context, userID pgtype.UUID) (GetReceiptStatisticsRow, error) {
	row := q.db.QueryRow(ctx, getReceiptStatistics, userID)
	var i GetReceiptStatisticsRow
	err := row.Scan(
		&i.TotalReceipts,
		&i.TotalSpent,
		&i.AverageReceiptAmount,
		&i.MinReceiptAmount,
		&i.MaxReceiptAmount,
	)
	return i, err
}

const getReceiptWithItems = `-- name: GetReceiptWithItems :one
WITH receipt_data AS (
    SELECT receipt_id, user_id, name_of_establishment, currency, number_of_items, subtotal, tax_value, tax_na, tip_value, tip_na, additional_charges_value, additional_charges_na, total, image_data, image_content_type, status, created_at, updated_at FROM receipts 
    WHERE receipt_id = $1
)
SELECT 
    r.receipt_id,
    r.user_id,
    r.name_of_establishment,
    r.currency,
    r.number_of_items,
    r.subtotal,
    r.tax_value,
    r.tax_na,
    r.tip_value,
    r.tip_na,
    r.additional_charges_value,
    r.additional_charges_na,
    r.total,
    r.image_data,
    r.image_content_type,
    r.status,
    r.created_at,
    r.updated_at,
    COALESCE(json_agg(
        json_build_object(
            'name', ri.name,
            'quantity', ri.quantity,
            'price_per_item', ri.price_per_item,
            'total_price', ri.total_price
        )
    ) FILTER (WHERE ri.receipt_id IS NOT NULL), '[]') AS items
FROM receipts r
LEFT JOIN receipt_items ri ON r.receipt_id = ri.receipt_id
WHERE r.receipt_id = $1
GROUP BY r.receipt_id
`

type GetReceiptWithItemsRow struct {
	ReceiptID              pgtype.UUID
	UserID                 pgtype.UUID
	NameOfEstablishment    pgtype.Text
	Currency               pgtype.Text
	NumberOfItems          int32
	Subtotal               pgtype.Numeric
	TaxValue               pgtype.Numeric
	TaxNa                  pgtype.Bool
	TipValue               pgtype.Numeric
	TipNa                  pgtype.Bool
	AdditionalChargesValue pgtype.Numeric
	AdditionalChargesNa    pgtype.Bool
	Total                  pgtype.Numeric
	ImageData              []byte
	ImageContentType       pgtype.Text
	Status                 bool
	CreatedAt              pgtype.Timestamptz
	UpdatedAt              pgtype.Timestamptz
	Items                  interface{}
}

func (q *Queries) GetReceiptWithItems(ctx context.Context, receiptID pgtype.UUID) (GetReceiptWithItemsRow, error) {
	row := q.db.QueryRow(ctx, getReceiptWithItems, receiptID)
	var i GetReceiptWithItemsRow
	err := row.Scan(
		&i.ReceiptID,
		&i.UserID,
		&i.NameOfEstablishment,
		&i.Currency,
		&i.NumberOfItems,
		&i.Subtotal,
		&i.TaxValue,
		&i.TaxNa,
		&i.TipValue,
		&i.TipNa,
		&i.AdditionalChargesValue,
		&i.AdditionalChargesNa,
		&i.Total,
		&i.ImageData,
		&i.ImageContentType,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Items,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT user_id, password_hash 
FROM users 
WHERE email = $1
`

type GetUserByEmailRow struct {
	UserID       pgtype.UUID
	PasswordHash string
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(&i.UserID, &i.PasswordHash)
	return i, err
}

const getUserReceipts = `-- name: GetUserReceipts :many
SELECT receipt_id, name_of_establishment, total, created_at, status
FROM receipts 
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetUserReceiptsParams struct {
	UserID pgtype.UUID
	Limit  int32
	Offset int32
}

type GetUserReceiptsRow struct {
	ReceiptID           pgtype.UUID
	NameOfEstablishment pgtype.Text
	Total               pgtype.Numeric
	CreatedAt           pgtype.Timestamptz
	Status              bool
}

func (q *Queries) GetUserReceipts(ctx context.Context, arg GetUserReceiptsParams) ([]GetUserReceiptsRow, error) {
	rows, err := q.db.Query(ctx, getUserReceipts, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserReceiptsRow
	for rows.Next() {
		var i GetUserReceiptsRow
		if err := rows.Scan(
			&i.ReceiptID,
			&i.NameOfEstablishment,
			&i.Total,
			&i.CreatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchReceipts = `-- name: SearchReceipts :many
SELECT receipt_id, name_of_establishment, total, created_at 
FROM receipts 
WHERE user_id = $1 
AND name_of_establishment ILIKE $2
ORDER BY created_at DESC
`

type SearchReceiptsParams struct {
	UserID              pgtype.UUID
	NameOfEstablishment pgtype.Text
}

type SearchReceiptsRow struct {
	ReceiptID           pgtype.UUID
	NameOfEstablishment pgtype.Text
	Total               pgtype.Numeric
	CreatedAt           pgtype.Timestamptz
}

func (q *Queries) SearchReceipts(ctx context.Context, arg SearchReceiptsParams) ([]SearchReceiptsRow, error) {
	rows, err := q.db.Query(ctx, searchReceipts, arg.UserID, arg.NameOfEstablishment)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchReceiptsRow
	for rows.Next() {
		var i SearchReceiptsRow
		if err := rows.Scan(
			&i.ReceiptID,
			&i.NameOfEstablishment,
			&i.Total,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReceiptStatus = `-- name: UpdateReceiptStatus :exec
UPDATE receipts 
SET status = $2 
WHERE receipt_id = $1
`

type UpdateReceiptStatusParams struct {
	ReceiptID pgtype.UUID
	Status    bool
}

func (q *Queries) UpdateReceiptStatus(ctx context.Context, arg UpdateReceiptStatusParams) error {
	_, err := q.db.Exec(ctx, updateReceiptStatus, arg.ReceiptID, arg.Status)
	return err
}
